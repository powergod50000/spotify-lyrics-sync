<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Spotify Auto Lyrics + Karaoke</title>

<style>
    :root {
        --bg: #111;
        --text: #eee;
        --accent: #1db954;
        --secondary-bg: #222;
    }
    body.light {
        --bg: #fafafa;
        --text: #111;
        --secondary-bg: #dcdcdc;
    }
    body {
        background: var(--bg);
        color: var(--text);
        font-family: sans-serif;
        padding: 20px;
        transition: background 0.3s, color 0.3s;
    }

    button {
        background: var(--accent);
        color: white;
        border: none;
        padding: 8px 14px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
    }
    button:disabled {
        opacity: 0.5;
        cursor: default;
    }
    #lyrics {
        margin-top: 10px;
        max-height: 70vh;
        overflow-y: auto;
    }
    #lyrics span {
        display: block;
        padding: 3px 0;
        font-size: 18px;
        transition: color 0.2s, font-size 0.2s;
    }
    .activeLine {
        color: var(--accent);
        font-weight: bold;
        font-size: 20px;
    }
    #queueBox {
        background: var(--secondary-bg);
        padding: 10px;
        border-radius: 6px;
        margin-top: 20px;
        display: none;
    }

    #controls {
        margin-top: 10px;
    }
    #controls button {
        margin-right: 6px;
        margin-top: 4px;
    }

    #songInfo {
        margin-top: 10px;
        font-size: 14px;
        opacity: 0.8;
    }

    #modeLabel {
        margin-top: 6px;
        font-size: 13px;
        opacity: 0.8;
    }
</style>
</head>

<body>

<h1>Spotify Auto Lyrics + Karaoke</h1>

<button id="loginBtn">Connect Spotify</button>
<button id="themeBtn">Toggle Theme</button>
<button id="queueBtn" style="display:none;">Show Queue</button>

<div id="controls" style="display:none;">
    <button onclick="spCommand('previous')">⏮</button>
    <button onclick="spCommand('pause')">⏸</button>
    <button onclick="spCommand('play')">▶</button>
    <button onclick="spCommand('next')">⏭</button>
    <!-- sync buttons -->
    <button id="syncMinus" style="margin-left:10px;">Sync -0.5s</button>
    <button id="syncPlus">Sync +0.5s</button>
</div>

<div id="songInfo">No track loaded yet.</div>
<div id="modeLabel">Mode: (none)</div>

<h2>Lyrics</h2>
<div id="lyrics">No lyrics loaded yet.</div>

<div id="queueBox">
    <h2>Queue</h2>
    <div id="queue"></div>
</div>

<script>
/* ----------------------------------------------------
   CONFIG
---------------------------------------------------- */
const CLIENT_ID = "a079b5566fff4c44b77ed45589888e1d";
const REDIRECT_URI = "https://spotify-lyrics-sync-tawny.vercel.app/";
const SCOPES = "user-read-playback-state user-read-currently-playing user-modify-playback-state";

// LRC files live at:
// https://raw.githubusercontent.com/powergod50000/spotify-lyrics-sync/main/timing/<file>.lrc
const TIMINGS_BASE_URL = "https://raw.githubusercontent.com/powergod50000/spotify-lyrics-sync/main/timing/";

let timestamps = [];
let fallbackTiming = [];
let lyricsLines = [];
let syncOffset = 0; // seconds, positive = lyrics later, negative = earlier
let lastTrackId = null;

/* ----------------------------------------------------
   THEME TOGGLE
---------------------------------------------------- */
document.getElementById("themeBtn").onclick = () => {
    document.body.classList.toggle("light");
    localStorage.setItem("theme", document.body.classList.contains("light") ? "light" : "dark");
};

if (localStorage.getItem("theme") === "light") {
    document.body.classList.add("light");
}

/* ----------------------------------------------------
   PKCE HELPERS
---------------------------------------------------- */
function randomStr(len) {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    return [...Array(len)].map(() => chars[Math.floor(Math.random() * chars.length)]).join("");
}

async function sha256(str) {
    return crypto.subtle.digest("SHA-256", new TextEncoder().encode(str));
}

function base64url(buf) {
    return btoa(String.fromCharCode(...new Uint8Array(buf)))
        .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

async function createChallenge(verifier) {
    return base64url(await sha256(verifier));
}

/* ----------------------------------------------------
   LOGIN FLOW
---------------------------------------------------- */
async function login() {
    const verifier = randomStr(128);
    localStorage.setItem("code_verifier", verifier);

    const challenge = await createChallenge(verifier);

    const params = new URLSearchParams({
        response_type: "code",
        client_id: CLIENT_ID,
        redirect_uri: REDIRECT_URI,
        scope: SCOPES,
        code_challenge_method: "S256",
        code_challenge: challenge
    });

    window.location = "https://accounts.spotify.com/authorize?" + params.toString();
}

/* ----------------------------------------------------
   TOKEN EXCHANGE & REFRESH
---------------------------------------------------- */
async function exchangeCode(code) {
    const verifier = localStorage.getItem("code_verifier");

    const body = new URLSearchParams({
        grant_type: "authorization_code",
        code,
        redirect_uri: REDIRECT_URI,
        client_id: CLIENT_ID,
        code_verifier: verifier
    });

    const data = await fetch("https://accounts.spotify.com/api/token", {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body
    }).then(r => r.json());

    saveToken(data);
}

function saveToken(data) {
    if (data.access_token) {
        localStorage.setItem("access_token", data.access_token);
        localStorage.setItem("expires_at", Date.now() + data.expires_in * 1000);
    }
    if (data.refresh_token) {
        localStorage.setItem("refresh_token", data.refresh_token);
    }
}

async function getToken() {
    const access = localStorage.getItem("access_token");
    const exp = Number(localStorage.getItem("expires_at"));

    if (access && Date.now() < exp) return access;

    const refresh = localStorage.getItem("refresh_token");
    if (!refresh) return null;

    const body = new URLSearchParams({
        grant_type: "refresh_token",
        refresh_token: refresh,
        client_id: CLIENT_ID
    });

    const data = await fetch("https://accounts.spotify.com/api/token", {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body
    }).then(r => r.json());

    saveToken(data);
    return data.access_token || null;
}

/* ----------------------------------------------------
   SPOTIFY API WRAPPER
---------------------------------------------------- */
async function sp(endpoint, method = "GET", body = null) {
    const token = await getToken();
    if (!token) return null;

    const res = await fetch("https://api.spotify.com/v1/" + endpoint, {
        method,
        headers: {
            Authorization: "Bearer " + token,
            "Content-Type": "application/json"
        },
        body: body ? JSON.stringify(body) : null
    });

    try {
        return await res.json();
    } catch (e) {
        return null;
    }
}

/* ----------------------------------------------------
   PLAYBACK CONTROLS
---------------------------------------------------- */
async function spCommand(cmd) {
    if (cmd === "next") await fetchSpotifyPlayer("me/player/next", "POST");
    if (cmd === "previous") await fetchSpotifyPlayer("me/player/previous", "POST");
    if (cmd === "pause") await fetchSpotifyPlayer("me/player/pause", "PUT");
    if (cmd === "play") await fetchSpotifyPlayer("me/player/play", "PUT");
}

async function fetchSpotifyPlayer(endpoint, method) {
    const token = await getToken();
    if (!token) return;

    const res = await fetch("https://api.spotify.com/v1/" + endpoint, {
        method,
        headers: {
            Authorization: "Bearer " + token,
            "Content-Type": "application/json"
        }
    });

    if (res.status === 403) {
        console.log("Spotify player command forbidden (need Premium or active device).");
    }
}

/* ----------------------------------------------------
   FETCH LYRICS FROM BACKEND (/api/lyrics -> lyrics.ovh)
---------------------------------------------------- */
async function fetchLyrics(title, artist) {
    const res = await fetch(
        `/api/lyrics?title=${encodeURIComponent(title)}&artist=${encodeURIComponent(artist)}`
    );

    if (!res.ok) {
        console.error("Lyrics API error", res.status);
        return "";
    }

    const data = await res.json();
    return data.lyrics || "";
}

/* ----------------------------------------------------
   NAME NORMALIZER FOR CASE-INSENSITIVE LRC
---------------------------------------------------- */
function normalizeName(str) {
    return str
        .toLowerCase()
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")   // remove accents
        .replace(/[^a-z0-9]+/g, "-")       // non-alphanumerics -> hyphens
        .replace(/^-+|-+$/g, "");          // trim hyphens
}

/* ----------------------------------------------------
   LRC LOADER FROM GITHUB (case-insensitive, flexible)
---------------------------------------------------- */
async function loadLrcFromGithub(track) {
    const artist = track.artists[0].name;
    const title = track.name;

    const a = normalizeName(artist);
    const t = normalizeName(title);

    // candidate filename patterns (all will be lowercased)
    const rawCandidates = [
        `${artist} - ${title}.lrc`,
        `${artist}-${title}.lrc`,
        `${artist}_${title}.lrc`,
        `${artist}${title}.lrc`,
        `${a}-${t}.lrc`,
        `${a}_${t}.lrc`,
        `${a}${t}.lrc`
    ];

    const candidates = Array.from(new Set(
        rawCandidates
            .filter(Boolean)
            .map(name => name.trim())
    ));

    ));

    let lrcText = null;
    let usedName = null;

    for (const fileName of candidates) {
        const url = `${TIMINGS_BASE_URL}${encodeURIComponent(fileName)}`;
        try {
            const res = await fetch(url);
            if (!res.ok) {
                console.log("No LRC at", fileName, "status:", res.status);
                continue;
            }
            lrcText = await res.text();
            usedName = fileName;
            break;
        } catch (err) {
            console.error("Error fetching LRC", fileName, err);
        }
    }

    if (!lrcText) {
        console.log("No matching LRC for", artist, "-", title);
        return false;
    }

    // Parse LRC text
    const lines = lrcText.split("\n");
    const parsed = [];

    for (let rawline of lines) {
        let line = rawline.trim();
        if (!line) continue;

        // ignore metadata tags like [ti:], [ar:], [al:], [by:], [offset:]
        if (/^\[(ti|ar|al|by|offset):/i.test(line)) continue;

        // match all [mm:ss] or [mm:ss.xxx] timestamps
        const tagRegex = /\[(\d{1,2}):(\d{2})(?:\.(\d{1,3}))?\]/g;
        let match;
        const timestampsForLine = [];

        while ((match = tagRegex.exec(line)) !== null) {
            const minutes = parseInt(match[1], 10);
            const seconds = parseInt(match[2], 10);
            const millis = match[3] ? parseInt(match[3].padEnd(3, "0"), 10) : 0;
            const timeInSeconds = minutes * 60 + seconds + millis / 1000;
            timestampsForLine.push(timeInSeconds);
        }

        const lyricText = line.replace(tagRegex, "").trim();
        if (!lyricText || timestampsForLine.length === 0) continue;

        for (const t of timestampsForLine) {
            parsed.push({ time: t, text: lyricText });
        }
    }

    if (!parsed.length) {
        console.log("LRC file has no timed lines for", usedName);
        return false;
    }

    parsed.sort((a, b) => a.time - b.time);

    const container = document.getElementById("lyrics");
    container.innerHTML = "";

    lyricsLines = [];
    timestamps = [];

    for (const entry of parsed) {
        const span = document.createElement("span");
        span.textContent = entry.text;
        container.appendChild(span);

        lyricsLines.push(entry.text);
        timestamps.push(entry.time);
    }

    fallbackTiming = [...timestamps];

    console.log("Loaded LRC file", usedName);
    document.getElementById("modeLabel").textContent = "Mode: Synced LRC (GitHub)";
    return true;
}

/* ----------------------------------------------------
   LOAD LYRICS (LRC FIRST, THEN FALLBACK)
---------------------------------------------------- */
async function loadLyrics() {
    const now = await sp("me/player/currently-playing");
    if (!now || now.error || !now.item) {
        document.getElementById("songInfo").textContent = "No active playback.";
        document.getElementById("lyrics").textContent = "No lyrics loaded.";
        return;
    }

    const track = now.item;
    const title = track.name;
    const artist = track.artists[0].name;
    const container = document.getElementById("lyrics");

    const trackId = track.id;
    const songInfo = `${artist} — ${title}`;
    document.getElementById("songInfo").textContent = songInfo;

    // If track changed, reset sync offset
    if (trackId !== lastTrackId) {
        syncOffset = 0;
        lastTrackId = trackId;
    }

    // 1) Try LRC from GitHub
    const usedLrc = await loadLrcFromGithub(track);
    if (usedLrc) {
        return;
    }

    // 2) Fallback: raw lyrics via /api/lyrics
    const raw = await fetchLyrics(title, artist);
    if (!raw.trim()) {
        container.innerHTML = "No lyrics found for this track.";
        document.getElementById("modeLabel").textContent = "Mode: No lyrics";
        lyricsLines = [];
        timestamps = [];
        fallbackTiming = [];
        return;
    }

    container.innerHTML = "";
    lyricsLines = raw.split("\n").filter(l => l.trim() !== "");

    lyricsLines.forEach(line => {
        const span = document.createElement("span");
        span.textContent = line;
        container.appendChild(span);
    });

    // approximate timing across duration
    fallbackTiming = lyricsLines.map((_, i) =>
        (track.duration_ms / lyricsLines.length) * i / 1000
    );

    document.getElementById("modeLabel").textContent = "Mode: Auto (lyrics.ovh)";
}

/* ----------------------------------------------------
   AUTO-HIGHLIGHT + AUTO-SCROLL
---------------------------------------------------- */
setInterval(async () => {
    if (!lyricsLines.length) return;

    const now = await sp("me/player/currently-playing");
    if (!now || now.error || !now.progress_ms) return;

    const baseTime = now.progress_ms / 1000;
    const current = baseTime + syncOffset;

    const timing = timestamps.length ? timestamps : fallbackTiming;
    if (!timing.length) return;

    let idx = 0;
    for (let i = 0; i < timing.length; i++) {
        if (current >= timing[i]) idx = i;
    }

    const spans = document.querySelectorAll("#lyrics span");
    spans.forEach(s => s.classList.remove("activeLine"));
    if (spans[idx]) {
        spans[idx].classList.add("activeLine");
        spans[idx].scrollIntoView({ behavior: "smooth", block: "center" });
    }

}, 900);

/* ----------------------------------------------------
   QUEUE VIEWER
---------------------------------------------------- */
async function loadQueue() {
    const data = await sp("me/player/queue");

    const box = document.getElementById("queueBox");
    const q = document.getElementById("queue");
    q.innerHTML = "";

    if (!data || data.error || !data.queue) {
        q.textContent = "Queue unavailable (need Premium + active device).";
        box.style.display = "block";
        return;
    }

    data.queue.forEach(t => {
        const d = document.createElement("div");
        d.textContent = t.name + " — " + t.artists.map(a => a.name).join(", ");
        q.appendChild(d);
    });

    box.style.display = "block";
}

/* ----------------------------------------------------
   SYNC OFFSET BUTTONS
---------------------------------------------------- */
document.getElementById("syncMinus").onclick = () => {
    syncOffset -= 0.5;
    console.log("Sync offset:", syncOffset);
};

document.getElementById("syncPlus").onclick = () => {
    syncOffset += 0.5;
    console.log("Sync offset:", syncOffset);
};

/* ----------------------------------------------------
   HANDLE REDIRECT + AUTO-LOGIN
---------------------------------------------------- */
(async function() {
    const params = new URLSearchParams(window.location.search);
    const code = params.get("code");

    if (code) {
        await exchangeCode(code);
        window.history.replaceState({}, "", REDIRECT_URI);
    }

    const token = await getToken();
    if (token) {
        document.getElementById("loginBtn").style.display = "none";
        document.getElementById("queueBtn").style.display = "inline-block";
        document.getElementById("controls").style.display = "block";
        loadLyrics();
    }
})();

document.getElementById("loginBtn").onclick = login;
document.getElementById("queueBtn").onclick = loadQueue;

</script>

</body>
</html>

